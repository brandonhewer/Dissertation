\documentclass[11pt,openright,hidelinks,a4paper]{article}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\usepackage{adjustbox}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bm}
\usepackage{float}
\usepackage{harvard}
\usepackage{pgfgantt}
\usepackage{tikz}
\usepackage[nottoc]{tocbibind}
\usetikzlibrary{arrows,shapes,automata,petri,cd}

\tikzset{
  place/.style={
    circle,
    thick,
    draw=black!75,
    fill=white!20,
    minimum size=6mm
  },
  transition/.style={
    rectangle,
    thick,
    fill=black,
    minimum width=8mm,
    inner ysep=2pt
  }
}

\input{../Definitions/DissertationDefs}

\title{A System for Exploring the Relationship Between Dinaturality and Parametric Polymorphism\\\large{Literature Review (Working version)}}
\author{Brandon Hewer}
\date{Bachelor of Science in Computer Science with Honours\\The University of Bath\\January 2019}

\begin{document}

\setcounter{page}{0}
\pagenumbering{roman}

\maketitle

\newpage

\tableofcontents
\newpage

\setcounter{page}{1}
\pagenumbering{arabic}

\lstset{language=Haskell,breaklines,breakatwhitespace,basicstyle=\small}

\section{Category Theory and Dinaturality}

\subsection{A formal approach to structure}
Category theory is a branch of mathematics concerned with the formalisation of structure. A category is a mathematical object consisting of two components: objects and morphisms. Objects represent `nodes' within a category, while morphisms are directed arrows with a domain and co-domain object. The set of objects in a category $\mathbb{C}$ will henceforth be denoted as $ob(\mathbb{C})$ while morphisms will be denoted as $hom(\mathbb{C})$. Two morphisms $f : X \rightarrow Y$ and $g : Y \rightarrow Z$ may be composed to create a new morphism $g \circ f$. Composition of morphisms is an associative operation:
\begin{equation}
  \forall f, g, h \in hom(\mathbb{C})\ |\ h \circ (g \circ f) = (h \circ g) \circ f
\end{equation}
Every object has an associated identity morphism:
\begin{equation}
  \forall X,\ Y \in
  ob(\mathbb{C})\ \forall f : X \rightarrow Y \in hom(\mathbb{C})\ |\ f \circ id_{X} = id_{Y} \circ f.
\end{equation}
Directed graphs are often used to represent categories. A category $\mathbb{C}$ with objects $ob(\mathbb{C}) = \{X, Y\}$ and morphisms $f : X \rightarrow Y$, $g : Y \rightarrow X$, may be represented by the following diagram:
\begin{equation}\label{category}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        X \arrow[r, bend right=40, "f"{below}]
        \arrow[loop left, "id_{X}"]
        &  Y \arrow[l, bend right=40, "g"{above}]
        \arrow[loop right, "id_{Y}"]
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
The diagram presented in \eqref{category} depicts two objects connected in a directed cyclic graph. The required identity morphism has been included for each object.

\subsection{Structure-preserving maps}
In category theory, a functor is a map between categories which preserves identity and composition. Formally, a functor $F : \mathbb{C} \rightarrow \mathbb{D}$ is defined as associating to each object $X$ in $\mathbb{C}$ an object $F (X)$ in $\mathbb{D}$ and to each morphism $f : X \rightarrow Y$ in $\mathbb{C}$ a morphism $F(f) : F(X) \rightarrow F(Y)$ in $\mathbb{D}$. Given the functor $F$, the following conditions must hold:
\begin{flalign}\label{functor-def}
  F (id_{X}) &= id_{F (X)},\\
  \forall f : X \rightarrow Y, g : Y \rightarrow Z &\in \mathbb{C} : F (g \circ f) = F (g) \circ F (f).
\end{flalign}

Add description of multifunctors and functors with multi-variance (e.g. profunctors).

\subsection{Natural transformations}
A natural transformation is a family of morphisms which collectively describe a structure-preserving map between two functors. The structure-preserving condition of a natural transformation $\eta_{X} : F(X) \rightarrow G(X)$ between two functors $F, G : \mathbb{C} \rightarrow \mathbb{D}$, is expressed by the following commutative diagram:
\begin{equation}\label{eq:naturality}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        F (X) \arrow[r, "F (f)"] \arrow[d, "\eta_{X}"']
        &  F (Y) \arrow[d, "\eta_{Y}"]
        \\ G (X) \arrow[r, "G (f)"]
        &  G (Y)
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}

An intuitive understanding of naturality, from a functional programming perspective, may be acquired by observing the properties of an example natural transformation. Such an example, in Haskell, is the parametrically polymorphic \lstinline{safeHead} function.
\begin{lstlisting}[
  breaklines,
  breakatwhitespace,
  caption={An implementation of \lstinline{safeHead} in Haskell},
  label={Haskell-SafeHead}
]
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead xs = Just . head $ xs
\end{lstlisting}

Listing \ref{Haskell-SafeHead} depicts an implementation of the \lstinline{safeHead} natural transformation from the \lstinline{List} functor to the \lstinline{Maybe} functor. It is evident that \lstinline{safeHead} exhibits the naturality condition; $\forall f : a \rightarrow b : \lstinline{fmap }f \lstinline{. safeHead} = \lstinline{safeHead . fmap } f$.
\\\\
The formulation of naturality depicted in \eqref{eq:naturality} does not encapsulate transformations between mixed-variance functors. Mixed variance may be found in functors whose domain or co-domain is a product category, such as any hom-functor $Hom(X',X) : \mathbb{C}^{op} \times \mathbb{C} \rightarrow Set$, where $\mathbb{C}^{op}$ is the opposite category of $\mathbb{C}$. \citeasnoun{GeneralTransform} advanced a more general conception of naturality, described as extranaturality, to account for transformations between mixed-variance functors. The structure-preserving condition of an extranatural transformation $\alpha_{X,Z} : F(X,X) \rightarrow G(Z,Z)$ between two functors $F : \mathbb{C}^{op} \times \mathbb{C} \rightarrow \mathbb{D}$ and $G : \mathbb{B}^{op} \times \mathbb{B} \rightarrow \mathbb{D}$, is expressed by the following commutative diagram:
\begin{equation}\label{eq:extranaturality}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        F (X', X) \arrow[r, "{F (id, f)}"] \arrow[d, "{F (f, id)}"']
        &  F (X', X') \arrow[d, "\alpha_{X'}"]
        \\ F (X, X) \arrow[r, "\alpha_{X}"]
        &  G (Z, Z)
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
In this formulation of naturality, the transformation $\alpha$ is said to be extranatural in X, providing Z does not depend on X.\\

Discuss the notion of the multi-variable functorial calculus described by \citeasnoun{ManyVariableFunctorialCalculus}.
\\

The extranaturality condition does not apply to transformations where mixed variance occurs in both the domain and co-domain. A bifunctor $F : \mathbb{C}^{op} \times \mathbb{C} \rightarrow Set$, described as being contravariant in its first argument and covariant in the second, is also known as a profunctor.  The structure-preserving condition of a dinatural transformation $\phi : F \rightarrow G$ between two profunctors, $F, G : \mathbb{C}^{op} \times \mathbb{C} \rightarrow \text{\textit{Set}}$ is expressed by the following commutative diagram:
\begin{equation}\label{dinaturality}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        &  F (X, X) \arrow[r, "\phi_{X}"]
        &  G (X, X) \arrow[dr, "{F (id, f)}"]
        &
        \\ F (X', X) \arrow[ur, "{F (f, id)}"] \arrow[dr, "{F (id, f)}"]
        &
        &
        &  G (X, X')
        \\
        &  F (X', X') \arrow[r, "\phi_{X'}"]
        &  G (X', X') \arrow[ur, "{F (f, id)}"]
        &
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
Examples of dinatural transformations include the Y-combinator $Y : (A \rightarrow A) \rightarrow A$ and the Church-numeral encoding e.g., $N_{1} : (A \rightarrow A) \rightarrow (A \rightarrow A)$. The composition of two dinatural transformation is not guaranteed to preserve dinaturality.

\subsection{Natural composition}
The vertical composition of two natural transformations $\eta_X : F(X) \rightarrow G(X)$ and $\gamma_X : G(X) \rightarrow H(X)$, is defined as $(\gamma \bullet \eta)_X = \gamma_X \circ \eta_X$. Vertical composition can also be depicted by the following commutative diagram:
\begin{equation}\label{eq:nat_vertical}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        F (X) \arrow[r, "F (f)"] \arrow[d, "\eta_{X}"']
        &  F (Y) \arrow[d, "\eta_{Y}"]
        \\ G (X) \arrow[r, "G (f)"] \arrow[d, "\gamma_{X}"']
        &  G (Y) \arrow[d, "\gamma_{Y}"]
        \\ H (X) \arrow[r, "H (f)"]
        &  H (Y)
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
Given two natural transformations $\alpha_X : F(X) \rightarrow G(X)$ and $\beta_X : H(X) \rightarrow K(X)$, with functors $F, G : \mathbb{C} \rightarrow \mathbb{D}$ and $H, K : \mathbb{D} \rightarrow \mathbb{E}$, their horizontal composition is defined as $\beta * \alpha = (K \circ \alpha) \bullet (\beta \circ F)$.
\\ \\
Describe the composition problem with regards to dinatural transformations.

\subsection{Connections in linear logic}
Briefly discuss proof nets, their connection to the categorical notion of a coherence condition.  Explore the relationship between the coherence condition and the composition problem for dinatural transformations described by \citeasnoun{LogicToDinaturality}

\section{Parametric Polymorphism}
Polymorphism, a ubiquitous concept throughout computer science, describes the application of a single operation to a set of possible data types. In his 1967 lecture titled `Fundamental Concepts in Programming Languages', \citeasnoun{Strachey} introduced the contrasting ideas of ad-hoc and parametric polymorphism.
\par
Ad-hoc polymorphism describes the class of polymorphic functions whose behaviour depends on the type to which they are applied. Parametric polymorphism describes the class of polymorphic functions which operate on the set of all types and whose behaviour is not dependant on the type to which they are applied. An example of a parametrically polymorphic function is the `map' function in the Haskell programming language (Listing \ref{Haskell-Map}).
\begin{lstlisting}[
  breaklines,
  breakatwhitespace,
  caption={The map function, as defined in Haskell},
  label={Haskell-Map}
]
map :: (A -> B) -> [A] -> [B]
map _ [] = []
map f (x:xs) = f x : map f xs
\end{lstlisting}
Parametrically polymorphic functions such as `map' may be described as acting exclusively on structure. A variety of formalisations of parametric polymorphism, which try to capture this intuition, have been developed. One such formal approach is the polymorphic lambda calculus.

\subsection{System F}
Parametric polymorphism can be formally described by the second-order polymorphic lambda calculus, also known as the Girard-Reynolds polymorphic lambda calculus or System F. The second-order polymorphic lambda calculus was independently discovered by \citeasnoun{GirardPolyLambda} and \citeasnoun{ReynoldsPolyLambda}.

System F extends the semantics of the simply typed lambda calculus, by introducing the notion of type-level universal quantification. Type-level abstraction is formally denoted with the upper-case $\Lambda$. The identity function is expressed in System F as
\begin{flalign}\label{eq:system_f_identity}
  \Lambda T.\ \lambda x^T.x\ .
\end{flalign}
A more complex example, function composition, requires the following construction:
\begin{flalign}\label{eq:system_f_composition}
  \Lambda TUV.\ \lambda f^{T \rightarrow U}. \lambda g^{U \rightarrow V}. \lambda x^T. g (f x)\ .
\end{flalign}
The reduction rule for type-level applications is expressed as
\begin{flalign}
  (\Lambda \tau.\ \sigma [\tau])\ t \rightarrow_{\beta} \sigma [t / \tau]
\end{flalign}
Girard and Reynolds demonstrate that for all sequences of conversion rules, System F converges. This is known as the strong normalisation property. In the context of System F, the strong normalisation property entails the absence of recursion and the guarantee of termination. Strongly-normalising languages, such as System F, are never Turing-complete and cannot describe self-interpretation.

System F permits the application of polymorphic types to type abstractions. Given a polymorphic type $\Lambda \alpha.\ \alpha \rightarrow \alpha$ and an object $t$ of this type, $t$ may be applied to itself to attain an object of type $(\Lambda \alpha.\ \alpha \rightarrow \alpha) \rightarrow (\Lambda \alpha.\ \alpha \rightarrow \alpha)$. An object of the resulting type may then be applied to $t$ to attain an object of type $\Lambda \alpha.\ \alpha \rightarrow \alpha$; the original type of t. This example demonstrates the impredicativity property of System F, in which self-referential semantics emerge.

The meaning of any polymorphic type in System F, from a set-theoretic perspective, can be defined in terms of all instances of that type (universal quantification). \citeasnoun{SystemFVariableTypes} discusses how this set-theoretic approach to interpreting types in System F creates a circularity problem, as a result of impredicativity. Girard introduces a category-theoretic semantics of System F, in which the behaviour of a polymorphic type is determined by its behaviour on a finite number of qualitative domains.

\citeasnoun{DinaturalInSystemF} formulates a sufficient condition for dinaturality, in both the Church and Curry-style second-order polymorphic lambda calculus. Lataillade first describes the syntactic category $\mathcal{T}$ for System F, in conjunction with
functors of the form $F[(\_,\_),X] : \mathcal{T}^{op} \times \mathcal{T} \rightarrow \mathcal{T}$. Each functor $F[(A,B),X]$ represents a substitution in which contravariant occurrences of the type variable $X$ are replaced with $A$ and covariant occurrences are replaced with $B$. The dinaturality condition between these substitution functors are used to create a sufficient condition for dinaturality in System F. In the Church-style second-order polymorphic lambda calculus, a term $T$ is described as being dinatural in a type variable $X$ if and only if $X$ is not in the set of free type variables across all type instantiations of the normal-form of $T$.

\subsection{Parametricity}
\citeasnoun{ReynoldsAbstraction1} developed a relation semantics for type expressions corresponding to the set-theoretic semantics of the second-order polymorphic lambda calculus (System F). This relational approach was introduced in order to replace the existing set-theoretic model (with homomorphic functions), which had failed to include higher-order functions in the formalisation.

An important technique used by Reynolds in his formulation of relation semantics for types is structural induction; proving a theorem holds for higher-order types given it holds for their constituent types. The conceptualisation of types as relations may be formally expressed by first introducing a set of binary relations from $A$ to $A'$, henceforth denoted $\textit{Types}(A,A')$, which is defined as
\begin{flalign}\label{eq:type_relations}
  \text{\textit{Types}}(A,\ A') = \{\, R : R \subseteq A \times A' \,\}.
\end{flalign}
Every value of a primitive type is related to itself by the identity relation. For any primitive type $A$, the identity relation is defined as
\begin{flalign}\label{eq:identity_relation}
  I_A = \{\,(a, a) : a \in A\,\} \in \text{\textit{Types}}(A,A).
\end{flalign}
Given two type relations $A \in \text{\textit{Types}}(T_1,\ T_2)$ and $A' \in \text{\textit{Types}}(T_1',\ T_2')$, a relation $A \rightarrow A' \in \text{\textit{Types}}(T_1 \rightarrow T_1',\ T_2 \rightarrow T_2')$ is defined by
\begin{flalign}\label{eq:function_relation}
  (f_1,\ f_2) \in A \rightarrow A' \leftrightarrow \forall (a_1, a_2) \in A,\ (f_1\ a_1,\ f_2\ a_2) \in A'.
\end{flalign}
This relation states that functions are related if and only if they map related arguments into related results. Given the two type relations $A$ and $A'$, a relation $A \times A' \in \text{\textit{Types}}(T_1 \times T_1',\ T_2 \times T_2')$ is defined by
\begin{flalign}\label{eq:product_relation}
  ((a_1,\ a_1'),\ (a_2,\ a_2')) \in A \times A' \leftrightarrow (a_1,\ a_2) \in A \land (a_1',\ a_2') \in A'.
\end{flalign}
This relation states that pairs are related if and only if each of their corresponding elements are related. Given the type relation $A$, a relation $A^{*} \in \text{\textit{Types}}(T_1^*,\ T_2^*)$ is defined by
\begin{flalign}\label{eq:list_relation}
  ([a_1,\ ...,\ a_n],\ [a_1',\ ...\ a_n']) \in A^{*} \leftrightarrow (a_1,\ a_1') \in A\ ...\ (a_n,\ a_n') \in A.
\end{flalign}
This relation states that two lists are related if and only if they are of equal length and each of their corresponding elements are related. Given a function between relations
\begin{flalign}\label{eq:rel_functor}
  \mathcal{F} : X \rightarrow Y,\ X \in \text{\textit{Types}}(T,\ T'), Y \in \text{\textit{Types}}(U,\ U'),
\end{flalign}
a relation $\forall A.\ \mathcal{F}(A) \in \text{\textit{Types}}(\forall T_1.\ F(T_1),\ \forall T_2.\ F'(T_2))$ is defined by
\begin{flalign}\label{eq:functor_relation}
  (f, f') \in \forall X.\ \mathcal{F}(X) \leftrightarrow \forall Y \in \text{\textit{Types}}(V,\  V'),\ (f_V,\ f_{V'}) \in \mathcal{F}(Y).
\end{flalign}
This relation states that two polymorphic functions are related if and only if they take related type arguments into related results.

The above formalisation presents a structural induction on type expressions, and generates the theorem stating that any type expression is in a relation with itself if and only if its constituent types are related. Reynold's abstraction theorem arises as a consequence of considering the domain and co-domain of such a relation as different representations of the same type (environments). The abstraction theorem states that any expression maps related environments to related values.

\citeasnoun{ReynoldsAbstraction2} further generalise the notion of types as relations by recasting the existing set-theoretic approach in a category-theoretic context. The notion of PL-categories introduced by \citeasnoun{SeelyPL} is modified by removing the requirement that the base category must be Cartesian-closed. This formulation of PL-categories by Ma and Reynolds is used to model the second-order polymorphic lambda calculus.

`Parametricity' is a term used to describe the same result as the abstraction theorem, applied to a wider context than changes in type representation. This idea is fundamental to \possessivecite{FreeTheorems} paper, Theorems for free, in which the abstraction theorem is interpreted as a method for generating free theorems for polymorphic types. To demonstrate  Wadler's method for generating free theorems, an example for the polymorphic `filter' function is given. Let \textit{filter} be a closed term of type
\begin{flalign}
  \text{\textit{filter}} : \forall X. (X \rightarrow Bool) \rightarrow X^* \rightarrow X^*.
\end{flalign}
The result of Reynold's abstraction theorem gives the relation
\begin{flalign}\label{eq:free_ex_1}
  (\text{\textit{filter}}, \text{\textit{filter}}) \in \forall \mathcal{X}. (\mathcal{X} \rightarrow Bool) \rightarrow \mathcal{X}^* \rightarrow \mathcal{X}^*.
\end{flalign}
Let \textit{Types}$(A,\ A')$ define that type $A$ is related to type $A'$. By definition of universal quantification on relations, the above equation \eqref{eq:free_ex_1} can be expressed as
\begin{flalign}
  \forall \mathcal{A} \in \text{\textit{Types}}(A,\ A'),\\
  (filter_{A},\ filter_{A'}) \in (\mathcal{A} \rightarrow Bool) \rightarrow \mathcal{A}^* \rightarrow \mathcal{A}^*.
\end{flalign}
By definition of $\rightarrow$ on relations, this in turn can be expressed as
\begin{flalign}
  \forall \mathcal{A} \in \text{\textit{Types}}(A,\ A'),\\
  \forall (f, f') \in (\mathcal{A} \rightarrow Bool),\\
  \forall (xs, xs') \in \mathcal{A}^*,\\
  (filter_A\ f\ xs,\ filter_{A'}\ f'\ xs') \in \mathcal{A}^*.
\end{flalign}
By specialising to the case where the relation $\mathcal{A}$ is a function, we can derive the free theorem
\begin{flalign}
  \forall a : A \rightarrow A',\ \forall f \in A \rightarrow Bool,\\
  a^* \circ \text{\textit{filter}}_A\ (f \circ a) = (\text{\textit{filter}}_{A'}\ f) \circ a^*.
\end{flalign}
\\
\citeasnoun{FreeImprovements} extend the relational semantics for types, by adding an integer representation of the call-by-value evaluation cost to the codomain. For each semantic operation its behaviour on the cost parameter is defined. For example, the cost of pairs and lists is defined to be the sum of the costs of their elements. Seidel and Voigtl{\"a}nder use this extension to the relational semantics to derive quantitative theorems about the runtime of terms within a restricted form of the polymorphic lambda calculus.

\subsection{Cut-free proofs}
Explain System F as a restricted form of the sequent calculus, on which cut-free elimination is formally defined.
Categorical approach to cut-free proofs; corresponding to the strong normalisation property in higher-order typed lambda calculus (systems yielding irreducible terms in a finite number of steps). This idea is linked to Reynold's notion of parametricity, as described by
\citeasnoun{NaturalAsNormalForms}, and brings together the ideas of parametric polymorphism, the lambda calculus and category theory.

\section{Petri nets}
Petri nets are a mathematical model of distributed computation, first conceptualised by  \citeasnoun{Petri} in his seminal paper Kommunikation mit Automaten. A Petri net consists of weighted, directed arcs between places and transitions. Places may contain tokens and a specific configuration of tokens is known as a marking. Each transition within a Petri net has incoming arcs from input places and outgoing arcs to output places. A transition is enabled when all of its input places contain a sufficient number of tokens, as defined by the weight of the respective incoming arc. Enabled transitions may fire, which results in the tokens in each input place being consumed and each output place being filled with the number of tokens specified by the respective outgoing arc.
\begin{figure}[H]
  \begin{center}
    \begin{tikzpicture}[node distance=1.3cm,>=stealth',bend angle=45,auto]

      \begin{scope}
        \node [place,tokens=2] (i1)                              {};
        \node [place,tokens=1] (i2)  [below of=i1]               {};
        \node [place,tokens=1] (i3)  [below of=i2]               {};

        \node [place]          (o1)  [right of=i1, xshift=15mm]  {};
        \node [place]          (o2)  [right of=i3, xshift=15mm]  {};

        \node [transition]     (t1)  [right of=i2, label=above:$t$] {}
        edge [pre]  node[swap] {2} (i1)
        edge [pre]                 (i2)
        edge [pre]                 (i3)
        edge [post] node[swap] {3} (o1)
        edge [post] node       {2} (o2);
      \end{scope}

      \begin{scope} [xshift=8cm]
        \node [place]          (i1')                              {};
        \node [place]          (i2') [below of=i1']               {};
        \node [place]          (i3') [below of=i2']               {};

        \node [place,tokens=3] (o1') [right of=i1', xshift=15mm]  {};
        \node [place,tokens=2] (o2') [right of=i3', xshift=15mm]  {};

        \node [transition]     (t1') [right of=i2', label=above:$t$] {}
        edge [pre]  node[swap] {2} (i1')
        edge [pre]                 (i2')
        edge [pre]                 (i3')
        edge [post] node[swap] {3} (o1')
        edge [post] node       {2} (o2');
      \end{scope}

      \draw[->,thick] ([xshift=15mm]t1 -| t1) -- ([xshift=-10mm]i2' -| i2')
      node [above=1mm,midway,text width=3cm,text centered]
      {transition $t$ fires};

    \end{tikzpicture}
  \end{center}
  \caption{Firing a transition in a Petri net with three input and two output places}
  \label{fig:PetriNet}
\end{figure}

Figure \ref{fig:PetriNet} depicts the marking of a Petri net before and after the firing of its single transition $t$. Prior to firing, the input places of $t$ contain the exact number of tokens defined by the incoming arcs (2, 1, 1), therefore enabling $t$. Once $t$ fires, the tokens in its input places are consumed and the outgoing arcs define the number of tokens which are inserted into the output places (3, 2).

\subsection{Formal definition}
Formally, a Petri net $N$ may be expressed as a 4-tuple $(P,T,D,M^0)$ where
\begin{flalign*}
  \hspace{0.75cm}&P \text{ is a finite set of places,}&\\
  &T \text{ is a finite set of transitions,}&\\
  &D \text{ is an incidence matrix of size } |P| \times |T| \text{ (the transition relation),}&\\
  &M^0 \text{ is the initial marking vector where $M^0_p$ is the number of tokens in place $p$}&
\end{flalign*}
The matrix $D$ of the Petri net $N$ may be defined as follows:
\begin{flalign}
  \hspace{0.75cm}&D^{-}_{pt} = \text{ the weight of the arc from $p \in P$ to $t \in T$,}&\\
  &D^{+}_{tp} = \text{ the weight of the arc from $t \in T$ to $p \in P$,}&\\
  &D \hspace{0.258cm}= \hspace{0.1cm}D^{+} - D^{-}.&\label{eq:transition_relation}
\end{flalign}
As a consequence of formulating the transition relation $D$ as a matrix, a firing sequence of the Petri net $N$ is defined as a vector $F$ where
\begin{flalign}
  \hspace{0.75cm}&F_{t} \hspace{1.26cm}= \text{ the number of times } t \in T \text{ is to fire,}&\\
  &DF + M_{0} = \text{ the marking of $N$ after executing sequence $F$.}&
\end{flalign}

\subsection{Reachability}
Reachability describes a class of computational problems characterised by deciding whether a specific state is reachable given an initial state and a set of permitted transformations. A formulation of this problem for Petri nets is to decide whether a specific marking is reachable in a given net, with a given initial marking. \citeasnoun{ReachibilityConditions} outline the class of Petri nets for which a necessary and sufficient condition for reachability is obtainable. Formally, for a Petri net $N$, described by the 4-tuple $(P,T,D,M^0)$, the set of reachable markings $R_N$ is defined as
\begin{flalign}
  R_N = \{\,M \mid \exists F : M = DF + M_0 \land F \text{ is a firing sequence of } N\,\}.
\end{flalign}

\citeasnoun{ReachabilityEXPSPACE} shows that the state reachability (coverability) problem for Petri nets is exp-space hard; solvable by a deterministic Turing machine in exponential space. Following this research, an algorithm for deciding state reachability in any given Petri net was derived by \citeasnoun{PetriNetAlgorithm}. Mayr extends the Karp-Miller tree construction for minimal coverability by using non-deterministic finite automata to restrict the transition sequence space.

\citeasnoun{ReachabilityUPPER} derive the best known upper-bound for the reachability problem in vector addition systems (Petri nets); recursive non-primitive cubic-Ackermannian space. \citeasnoun{ReachibilityNotElementary} show that the general reachability problem for Petri nets does not have an elementary lower bound. The lower bound for reachability is shown to be an exponential tower where the height of the tower is an elementary function of the size of the transition space.

\subsection{Lambek-Lawvere Correspondence}
Brief description of curry-howard isomorphism, described by \citeasnoun{CurryHoward} and its importance in formalising computation (such notions of proofs in computation have now been extended to modern areas of research such as homotopy type theory).
\newline\newline
Introduce Lambek-Lawvere correspondence, a restriction of the curry-howard isomorphism, described by categorical grammars -- this is particularly fascinating in light of a paper by \citeasnoun{PetriNetToLinear} which brings together the notions of the categorical grammar with Petri nets.

\section{A Natural Model of Parametric Polymorphism}
Dinatural transformations have been investigated as a formal model for parametric polymorphism.

\subsection{Functorial Polymorphism}
\citeasnoun{FunctorialPolymorphism} introduce a formal model of parametric polymorphism in which the parametricity property is described by naturality conditions. Given a cartesian-closed category $\mathbb{C}$ of primitive types, multi-variance functors of the form $F : (\mathbb{C}^{op})^n \times \mathbb{C}^n \rightarrow \mathbb{C}$ can be interpreted as polymorphic types. Dinatural transformations between

Summary of dinaturality in category of partial equivalence relations, as described by \citeasnoun{DinaturalityInPERS} and how this corresponds to parametric polymorphism.
\newline\newline
Describe the problem of dinatural composition in relation to a model for parametric polymorphism (why is this a concern? would imposing further constraints on the discussed model of parameteric polymorphism, in order to only permit composable dinatural transformations, provide an improvement on the model? what implications are there for functional programming languages?).

\subsection{Extensions to the functorial polymorphism}
Discuss existing extensions to the functorial polymorphism and the `solutions' to the composition problem in the literature.
\newline\newline
\citeasnoun{StructuralPolymorphism} describe the notion of `structors'; a generalisation of functors which carry morphisms to spans of morphisms.
\newline\newline
\citeasnoun{CanonicalDinatural} define `canonical dinatural transformations', a constrained form of dinatural transformations, and relates them to context-free grammars and the polymorphic operator.
\newline\newline
Lead in to the next section on a new constraint in the literature involving petri nets and reachability.

\subsection{Dinatural composition to reachability}
In their paper, `On Compositionality of Dinatural Transformations', \citeasnoun{DinaturalCompose} make use of Petri net models in order to establish conditions under which the composition of dinatural transformations preserves dinaturality. The concept of modelling dinatural transformations with Petri nets and imposing constraints to ensure compositionality, could be developed into a computational system further exploring this idea.
\newline\newline
Formally state the intended project as a product of the reviewed literature.


\newpage
\bibliography{LiteratureReview}

\end{document}
