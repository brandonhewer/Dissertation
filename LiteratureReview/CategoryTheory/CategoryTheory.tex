% !TeX root = CategoryTheory.tex
\documentclass[../../Dissertation.tex]{subfiles}

\begin{document}

\subsection{A formal approach to structure}
Category theory is a branch of mathematics concerned with the formalisation of structure. A category is a mathematical object consisting of two components: objects and morphisms. Objects represent `nodes' within a category, while morphisms are directed arrows with a domain and co-domain object. The set of objects in a category $\mathbb{C}$ will henceforth be denoted as $ob(\mathbb{C})$ while the set of morphisms will be denoted as $hom(\mathbb{C})$. The set of morphisms between two objects $X, Y \in ob(\mathbb{C})$ will be denoted $hom(X, Y)$. Two morphisms $f : X \rightarrow Y$ and $g : Y \rightarrow Z$ may be composed to create a new morphism $g \circ f$. Composition of morphisms is an associative operation:
\begin{equation}
  \forall f, g, h \in hom(\mathbb{C})\ |\ h \circ (g \circ f) = (h \circ g) \circ f.
\end{equation}
Every object has an associated identity morphism:
\begin{equation}
  \forall X,\ Y \in
  ob(\mathbb{C})\ \forall f : X \rightarrow Y \in hom(\mathbb{C})\ |\ f \circ id_{X} = id_{Y} \circ f.
\end{equation}
Directed graphs are often used to represent categories. A category $\mathbb{C}$ with objects $ob(\mathbb{C}) = \{X, Y\}$ and morphisms $f : X \rightarrow Y$, $g : Y \rightarrow X$, may be represented by the following diagram:
\begin{equation}\label{category}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        X \arrow[r, bend right=40, "f"{below}]
        \arrow[loop left, "id_{X}"]
        &  Y \arrow[l, bend right=40, "g"{above}]
        \arrow[loop right, "id_{Y}"]
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
The diagram presented in \eqref{category} depicts two objects connected in a directed cyclic graph. The required identity morphism has been included for each object.
\par
A prominent example of a category, which is of particular interest to functional programmers, is the category of types and functions in the Haskell programming language. This category is termed \lstinline{Hask}, and its objects are given by types in Haskell. Morphisms from \lstinline{X} to \lstinline{Y} are given by functions of the type \lstinline{X -> Y}. The identity morphism on a type \lstinline{X} is given by the function \lstinline{id :: X -> X}. Composition is given by the \lstinline{(.)} function.

\subsection{Product and opposite categories}
Given two categories $\mathbb{C}$ and $\mathbb{D}$, their product, denoted $\mathbb{C} \times \mathbb{D}$, is the category whose objects are pairs of the form $(X, Y)$, $X \in ob(\mathbb{C})$, $Y \in ob(\mathbb{D})$. For all pairs of morphisms 
\begin{flalign}
f : X \rightarrow X' \in hom(\mathbb{C}),\ g : Y \rightarrow Y' \in hom(\mathbb{D}),
\end{flalign}
there exists a morphism 
\begin{flalign}
(f, g) : (X, Y) \rightarrow (X', Y') \in hom(\mathbb{C} \times \mathbb{D}).
\end{flalign}
Given morphisms $f : X \rightarrow Y$, $f' : Y \rightarrow Z \in hom(\mathbb{C})$ and $g : X' \rightarrow Y'$, $g' : Y' \rightarrow Z' \in hom(\mathbb{D})$, composition of morphisms $(f, g)$, $(f',g') \in hom(\mathbb{C} \times \mathbb{D})$ is given by
\begin{flalign}
  (f', g') \circ (f, g) = (f' \circ f, g' \circ g).
\end{flalign}
The identity morphism on an object $(X, Y) \in ob(\mathbb{C} \times \mathbb{D})$ is given by
\begin{flalign}
  id_{(X,Y)} = (id_X, id_Y).
\end{flalign}
The product of two categories is also known as a product category. Another ubiquitous operation performed on categories is the reversal of morphisms, to form an opposite category. Formally, given a category $\mathbb{C}$ the opposite category, denoted $\mathbb{C}^{op}$, is the category given by
\begin{flalign}
  ob(\mathbb{C}^{op}) &= ob(\mathbb{C}),\\
  hom_{\mathbb{C}^{op}}(X, Y) &= hom_{\mathbb{C}}(Y, X),\\
  id_X \in hom(\mathbb{C}) &= id_X \in hom(\mathbb{C}^{op}),\\
  \forall f : X \rightarrow Y,\ g : Y \rightarrow Z \in \mathbb{C}^{op}\ &|\ g \circ_{\mathbb{C}^{op}} f = f \circ_{\mathbb{C}} g.
\end{flalign} 

\subsection{Structure-preserving maps}\label{section:functor}
In category theory, a functor is a map between categories which preserves identity and composition. Formally, a functor $F : \mathbb{C} \rightarrow \mathbb{D}$ is defined as associating to each object $X$ in $\mathbb{C}$ an object $F (X)$ in $\mathbb{D}$ and to each morphism $f : X \rightarrow Y$ in $\mathbb{C}$ a morphism $F(f) : F(X) \rightarrow F(Y)$ in $\mathbb{D}$. Given the functor $F$, the following conditions must hold:
\begin{flalign}\label{functor-def}
  F (id_{X}) &= id_{F (X)},\\
  \forall f : X \rightarrow Y, g : Y \rightarrow Z &\in \mathbb{C} : F (g \circ f) = F (g) \circ F (f).
\end{flalign}
An example of a functor, provided within the Haskell programming language, is the list functor, as shown in \lstref{Haskell-List}.
\begin{lstlisting}[
  caption={An instantiation of the list functor in Haskell},
  label={Haskell-List}
]
instance Functor [] where
  fmap f []     = []
  fmap f (x:xs) = f x : (fmap f xs)
\end{lstlisting}
The list functor, \lstinline{[] : Hask -> Hask}, where \lstinline{Hask} is the category of Haskell types, maps any type \lstinline{a} to a type \lstinline{[a]}. Morphisms of the type \lstinline{f : a -> b} are lifted to \lstinline{[a] -> [b]} by defining a function which applies \lstinline{f} to every element in a list. A functor whose co-domain category is the same as its domain, such as \lstinline{[]}, is termed an endo-functor.

The definition of a functor generalises to the notion of a multifunctor. A multifunctor is a functor of the form $\mathbb{C}_1 \times \mathbb{C}_2 \times \cdots \times \mathbb{C}_n \rightarrow \mathbb{D}$, i.e., a functor whose domain is a product category. An example of a multifunctor is given by the product bifunctor in the Haskell programming language, as shown in Listing \ref{Haskell-Product}.

\begin{lstlisting}[
  caption={An instantiation of the product bifunctor in Haskell},
  label={Haskell-Product}
]
instance Bifunctor (,) where
  bimap f g (x, y) = (f x, g y)
\end{lstlisting}
In the given formulation, if there exists $\mathbb{C}_i, \mathbb{C}_j$, such that $\mathbb{C}_i^{op} = \mathbb{C}_j$, the multifunctor is said to be of mixed variance. An important example of a multifunctor is the hom-functor of a category $\mathbb{C}$, which is of the form $\mathbb{C}^{op} \times \mathbb{C} \rightarrow Set$, and is a functor from pairs of objects in $\mathbb{C}$ to their hom-sets in $Set$. An example of a hom-functor is given by the arrow profunctor in the Haskell programming language, as depicted in Listing \ref{Haskell-Arrow}.

\begin{lstlisting}[
  caption={An instantiation of the arrow profunctor in Haskell},
  label={Haskell-Arrow}
]
instance Profunctor (->) where
  dimap f h g = h . g . f
\end{lstlisting}

\subsection{Natural transformations}
A natural transformation is a family of morphisms which collectively describe a structure-preserving map between two functors. The structure-preserving condition of a natural transformation $\eta_{X} : F(X) \rightarrow G(X)$ between two functors $F, G : \mathbb{C} \rightarrow \mathbb{D}$, is expressed by the following commutative diagram:
\begin{equation}\label{eq:naturality}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        F (X) \arrow[r, "F (f)"] \arrow[d, "\eta_{X}"']
        &  F (Y) \arrow[d, "\eta_{Y}"]
        \\ G (X) \arrow[r, "G (f)"]
        &  G (Y)
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}

An intuitive understanding of naturality, from a functional programming perspective, may be acquired by observing the properties of an example natural transformation. Such an example, in Haskell, is the parametrically polymorphic \lstinline{safeHead} function.
\begin{lstlisting}[
  breaklines,
  breakatwhitespace,
  caption={An implementation of \lstinline{safeHead} in Haskell},
  label={Haskell-SafeHead}
]
safeHead :: [a] -> Maybe a
safeHead []     = Nothing
safeHead (x:_)  = Just x
\end{lstlisting}

Listing \ref{Haskell-SafeHead} depicts an implementation of the \lstinline{safeHead} natural transformation from the \lstinline{List} functor to the \lstinline{Maybe} functor. It is evident that \lstinline{safeHead} exhibits the naturality condition; given any function \lstinline{f : a -> b} the following equality holds:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
fmap f . safeHead = safeHead . fmap f.
\end{lstlisting}
\end{tabular}
\end{center}
\par
The formulation of naturality depicted in \eqref{eq:naturality} does not encapsulate transformations between mixed-variance functors. As described in Section \ref{section:functor}, mixed variance may be found in functors whose domain or co-domain is a product category, such as any hom-functor $Hom_{\mathbb{C}} : \mathbb{C}^{op} \times \mathbb{C} \rightarrow Set$, where $\mathbb{C}^{op}$ is the opposite category of $\mathbb{C}$. \citeasnoun{GeneralTransform} advanced a more general conception of naturality, known as extranaturality, to account for transformations between mixed-variance functors. The structure-preserving condition of an extranatural transformation $\alpha_{X,Z} : F(X,X) \rightarrow G(Z,Z)$ between two functors $F : \mathbb{C}^{op} \times \mathbb{C} \rightarrow \mathbb{D}$ and $G : \mathbb{B}^{op} \times \mathbb{B} \rightarrow \mathbb{D}$, is expressed by the following commutative diagram:
\begin{equation}\label{eq:extranaturality}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        F (X', X) \arrow[r, "{F (id, f)}"] \arrow[d, "{F (f, id)}"']
        &  F (X', X') \arrow[d, "\alpha_{X', Z}"]
        \\ F (X, X) \arrow[r, "\alpha_{X, Z}"]
        &  G (Z, Z)
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
In this formulation of naturality, the transformation $\alpha$ is said to be extranatural in X, providing Z does not depend on X. An example of an extranatural transformation is the parametrically polymorphic evaluation map.
\begin{lstlisting}[
  breaklines,
  breakatwhitespace,
  caption={An implementation of an evaluation map function in Haskell},
  label={Haskell-Eval}
]
eval :: (a -> b, a) -> b
eval (f, x) = f x
\end{lstlisting}
\lstref{Haskell-Eval} depicts an implementation of the evaluation map, which is extranatural in the type variable \lstinline{a}. By observation, the extranaturality condition can be verified; given any function \lstinline{f : a -> b}, the following equality holds:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
eval . bimap id f = eval . bimap (. f) id.
\end{lstlisting}
\end{tabular}
\end{center}
\par
The extranaturality condition does not extend to transformations in which mixed variance is present in both the domain and co-domain. A more general notion of naturality is required to describe such a family of morphisms; dinaturality. Given two functors $F, G : \mathbb{C}^{op} \times \mathbb{C} \rightarrow \mathbb{D}$, the structure-preserving condition of a dinatural transformation $\phi : F \rightarrow G$ is described by the following commutative diagram:
\begin{equation}\label{dinaturality}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        &  F (X, X) \arrow[r, "\phi_{X}"]
        &  G (X, X) \arrow[dr, "{G (id, f)}"]
        &
        \\ F (X', X) \arrow[ur, "{F (f, id)}"] \arrow[dr, swap, "{F (id, f)}"]
        &
        &
        &  G (X, X')
        \\
        &  F (X', X') \arrow[r, swap, "\phi_{X'}"]
        &  G (X', X') \arrow[ur, swap, "{G (f, id)}"]
        &
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
Examples of dinatural transformations include the Y-combinator $Y : (A \rightarrow A) \rightarrow A$ and the Church-numeral encoding e.g., $N_{1} : (A \rightarrow A) \rightarrow (A \rightarrow A)$. An example of the dinatural transformation, fix, in the Haskell programming language, is given in Listing \ref{Haskell-Y}.

\begin{lstlisting}[
  breaklines,
  breakatwhitespace,
  caption={An implementation of the fix function (Y-Combinator) in Haskell},
  label={Haskell-Y}
]
fix :: (a -> a) -> a
fix f = let x = f x in x
\end{lstlisting}
By observation, the dinaturality condition for the fix function can be verified; given functions \lstinline{f : b -> a} and \lstinline{g : a -> b}, the following equality holds:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
fix (g . f) = g . fix (f . g).
\end{lstlisting}
\end{tabular}
\end{center}

\subsection{Natural composition}
The vertical composition of two natural transformations $\eta_X : F(X) \rightarrow G(X)$ and $\gamma_X : G(X) \rightarrow H(X)$, is defined as $(\gamma \bullet \eta)_X = \gamma_X \circ \eta_X$. Vertical composition can also be depicted by the following commutative diagram:
\begin{equation}\label{eq:nat_vertical}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        F (X) \arrow[r, "F (f)"] \arrow[d, "\eta_{X}"']
        &  F (Y) \arrow[d, "\eta_{Y}"]
        \\ G (X) \arrow[r, "G (f)"] \arrow[d, "\gamma_{X}"']
        &  G (Y) \arrow[d, "\gamma_{Y}"]
        \\ H (X) \arrow[r, "H (f)"]
        &  H (Y)
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
Given two natural transformations $\alpha_X : F(X) \rightarrow G(X)$ and $\beta_X : H(X) \rightarrow K(X)$, with functors $F, G : \mathbb{C} \rightarrow \mathbb{D}$ and $H, K : \mathbb{D} \rightarrow \mathbb{E}$, their horizontal composition is defined as $(\beta * \alpha)_X = K (\alpha_X) \circ \beta_{F(X)}$. Horizontal composition may also be depicted by the following commutative diagram:
\begin{equation}\label{eq:nat_vertical}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        \mathbb{C}
        \arrow[r, bend left=60, "F"{name=F, above}]
        \arrow[r, swap, bend right=60, "G"{name=G, below}]
        \arrow[r, Rightarrow, from=F, to=G, shorten <= 2.6pt, shorten >= 2.6pt, "\alpha"{}]
        &
        \mathbb{D}
        \arrow[r, bend left=60, "H"{name=H, above}]
        \arrow[r, swap, bend right=60, "K"{name=K, below}]
        \arrow[r, Rightarrow, from=H, to=K, shorten <= 2.6pt, shorten >= 2.6pt, "\beta"{}]
        &
        \mathbb{E}
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
\\
Vertical and horizontal composition of natural transformations are related by the interchange law. The interchange law states that given natural transformations $\alpha$, $\alpha'$, $\beta$, $\beta'$ there is an equality $(\beta' * \alpha') \bullet (\beta * \alpha) = (\beta' \bullet \beta) * (\alpha' \bullet \alpha)$. The interchange law can intuitively be understood by observing the equality of composing commutative diagrams:
\begin{equation}\label{eq:nat_vertical}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}[row sep=tiny]
        \mathbb{C}
        \arrow[r, bend left=60, ""{name=LU, above}]
        \arrow[r, swap, ""{name=LM, above}]
        \arrow[r, Rightarrow, yshift=-2.1, from=LU, to=LM, "\hspace{1.8pt}\alpha"{}]
        &
        \mathbb{D}
        \arrow[r, bend left=60, ""{name=RU, above}]
        \arrow[r, swap, ""{name=RM, above}]
        \arrow[r, Rightarrow, yshift=-2.1, from=RU, to=RM, "\hspace{1.8pt}\beta"{}]
        &
        \mathbb{E}
        \\
        &\bullet&
        \\
        \mathbb{C}
        \arrow[r, swap, ""{name=LM, above}]
        \arrow[r, bend right=60, ""{name=LD, below}]
        \arrow[r, Rightarrow, yshift=0.8, shorten <= 2.5pt, from=LM, to=LD, "\hspace{1.8pt}\alpha'"{}]
        &
        \mathbb{D}
        \arrow[r, swap, ""{name=RM, above}]
        \arrow[r, bend right=60, ""{name=RD, below}]
        \arrow[r, Rightarrow, yshift=0.8, shorten <= 2.5pt, from=RM, to=RD, "\hspace{1.8pt}\beta'"{}]
        &
        \mathbb{E}
      \end{tikzcd}
      =
      \begin{tikzcd}
        \mathbb{C}
        \arrow[r, bend left=60, ""{name=LU, above}]
        \arrow[r, swap, ""{name=LM, above}]
        \arrow[r, bend right=60, ""{name=LD, below}]
        \arrow[r, Rightarrow, yshift=-2.1, from=LU, to=LM, "\hspace{1.8pt}\alpha"{}]
        \arrow[r, Rightarrow, yshift=0.8, shorten <= 2.5pt, from=LM, to=LD, "\hspace{1.8pt}\alpha'"{}]
        &
        \mathbb{D}
        &[-30pt]
        *
        &[-30pt]
        \mathbb{D}
        \arrow[r, bend left=60, ""{name=RU, above}]
        \arrow[r, swap, ""{name=RM, above}]
        \arrow[r, bend right=60, ""{name=RD, below}]
        \arrow[r, Rightarrow, yshift=-2.1, from=RU, to=RM, "\hspace{1.8pt}\beta"{}]
        \arrow[r, Rightarrow, yshift=0.8, shorten <= 2.5pt, from=RM, to=RD, "\hspace{1.8pt}\beta'"{}]
        &
        \mathbb{E}
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
\\
The notion of vertical and horizontal composition, and the associated interchange law, extends to the more general notion of 2-cells in any strict 2-category. In the given examples, the strict 2-category is the category $Cat$. In $Cat$, objects, known as 0-cells, are locally small categories. Morphisms  in $Cat$ are functor categories, in which objects (1-cells) are functors and morphisms (2-cells) are natural transformations.

Following from the well-defined notion of composition of natural transformations, it is reasonable to pursue a similar formulation in the generalised dinatural case. Unfortunately, such a pursuit leads to a notorious problem; in general, dinatural transformations do not compose. Formally, given functors $F,\ G,\ H : \mathbb{C}^{op} \times \mathbb{C} \rightarrow \mathbb{D}$ and dinatural transformations $\phi : F \rightarrow G$,  $\psi : G \rightarrow H$, it is not necessarily true that the outer hexagon in the following diagram commutes:

\begin{equation}\label{eq:dicompose}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1] (a) at (0,0) {
      \begin{tikzcd}[column sep=small]
        &  F (X, X)  \arrow[r, "\phi_{X}"]
        &  G (X, X)  \arrow[dr, swap, "{G (id, f)}"] \arrow[r, "\psi_{X}"]
        &  H (X, X)  \arrow[dr, "{H (id, f)}"]
        &
        \\ F (X', X) \arrow[ur, "{F (f, id)}"] \arrow[dr, swap, "{F (id, f)}"]
        &  G (X', X) \arrow[ur, swap, "{G (f, id)}"] \arrow[dr, "{G (id, f)}"]
        &
        &  G (X, X')
        &  H (X, X')
        \\
        &  F (X', X') \arrow[r, swap, "\phi_{X'}"]
        &  G (X', X') \arrow[ur, "{G (f, id)}"] \arrow[r, swap, "\psi_{X'}"]
        &  H (X', X') \arrow[ur, swap, "{H (f, id)}"]
        &
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
\\
To prove that this is indeed the case, a counterexample is presented, described by \citeasnoun{FunctorialPolymorphism}. Define three endofunctors, in the category $Set$,
\begin{flalign}\label{func-def}
  Hom : Set^{op} \times Set \rightarrow Set,\ 
  K_{BOOL} : Set^{op} \times Set \rightarrow Set,\ 
  K_{1} : Set \rightarrow Set,
\end{flalign}
where $Hom$ is the hom-functor, and $K_{BOOL}$, $K_1$ are constant functors which map into $\{0, 1\}$ and the one-element set, respectively. Consider the two dinatural transformations 
\begin{flalign}\label{nat-def}
  \psi : K_1 \rightarrow Hom,\ \phi : Hom \rightarrow K_{BOOL},
\end{flalign}
where $\psi_X$ always maps to the identity on $X$, and $\phi_X$ is defined as follows:
\begin{flalign}\label{nat-def}
  \phi_X (f) = 
  \begin{cases}
    0 & \text{if number of fixed points of } \textit{f} \text{ is even or not finite}\\
    1 & \text{otherwise}
  \end{cases}.
\end{flalign}
If the composition of $\phi$ and $\psi$ is dinatural, the resulting family of morphisms should satisfy the condition described by the commuting hexagon depicted in (\ref{eq:dinaturality}). It is clear that the family of morphisms $(\phi \cdot \psi)_X : K_1(X) \rightarrow K_{BOOL}(X)$ is a map between constant functors, and therefore, to be dinatural, must only describe a single morphism. However, the family of morphisms $(\phi \cdot \psi)_X$ is dependant on $X$, and describes two morphisms; one for each of the two possible parities of the number of fixpoints.
\par
In the circumstance in which the centre diamond found in (\ref{eq:dicompose}) is a pullback, the outer hexagon commutes, and the composition is dinatural. Formally, this diamond is a pullback if for all objects $Y$ and morphisms $f : Y \rightarrow G(X, X)$, $g : Y \rightarrow G(X', X')$, there exists a unique morphism $h : Y \rightarrow G(X', X)$, such that the following diagram commutes:

\begin{equation}\label{eq:dinaturality}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.15] (a) at (0,0) {
      \begin{tikzcd}
        Y \arrow[dr, "h"] \arrow[ddr, bend right=40, swap, "g"] \arrow[drr, bend left=20, "f"]
        &
        &
        \\[18pt]
        &
        G(X', X) \arrow[r, "{G(f, id)}"] \arrow[d, swap, "{G(id, f)}"]
        &
        G (X, X) \arrow[d, "{G(id, f)}"]
        \\
        &
        G(X', X') \arrow[r, swap, "{G(f, id)}"]
        &
        G(X, X')
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}

\subsection{Whiskering}
Whiskering is an instance of horizontal composition of 2-cells, in which one 2-cell is taken to be the identity on a 1-cell. By identifying a 1-cell with its associated identity 2-cell, it is possible to formalise the notion of horizontal composition of a 2-cell with a 1-cell. Pre-composing a 2-cell with a 1-cell is termed left whiskering, while post-composing is termed right whiskering.
\par
In the category $Cat$, whiskering translates to a technique for defining the horizontal composition of a natural transformation with a functor. Let $F, G : \mathbb{C} \rightarrow \mathbb{D}$ and $H, K: \mathbb{D} \rightarrow \mathbb{E}$ be functors, and $\alpha : F \rightarrow G, \beta : H \rightarrow K$ be natural transformations. Whiskering $F$ and $\beta$ is achieved by associating $F$ with $id_F : F \rightarrow F$, and is depicted by the following commutative diagram:

\begin{equation}\label{eq:nat_vertical}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        \mathbb{C} \arrow[r, "F"{name=F, above}]
        &
        \mathbb{D}
        \arrow[r, bend left=60, "H"{name=H, above}]
        \arrow[r, swap, bend right=60, "K"{name=K, below}]
        \arrow[r, Rightarrow, from=H, to=K, shorten <= 2.6pt, shorten >= 2.6pt, "\beta"{}]
        &
        \mathbb{E}
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
\\
This may also be formulated with the equation $(\beta * F)_X = \beta_{F(X)}$. Whiskering $G$ and $\beta$ can be achieved in an identical fashion; by associating $G$ with the natural transformation $id_G : G \rightarrow G$. Alternatively, whiskering $\alpha$ and $H$ is achieved by associating $H$ with $id_H : H \rightarrow H$, and is depicted by the following commutative diagram:

\begin{equation}\label{eq:nat_vertical}
  \begin{tikzpicture}[baseline= (a).base]
    \node[scale=1.2] (a) at (0,0) {
      \begin{tikzcd}
        \mathbb{C}
        \arrow[r, bend left=60, "F"{name=F, above}]
        \arrow[r, swap, bend right=60, "G"{name=G, below}]
        \arrow[r, Rightarrow, from=F, to=G, shorten <= 2.6pt, shorten >= 2.6pt, "\alpha"{}]
        &
        \mathbb{D} \arrow[r, "H"{name=H, above}]
        &
        \mathbb{E}
      \end{tikzcd}.
    };
  \end{tikzpicture}
\end{equation}
\\
This may also be formulated with the equation $(H * \alpha)_X = H (\alpha_X)$. Once again, whiskering $\alpha$ and $K$ is achieved in an identical manner; associating $K$ with the natural transformation $id_K : K \rightarrow K$. Two equivalent definitions of the horizontal composition of $\alpha$ and $\beta$ are described in terms of whiskering:
\begin{flalign}\label{horizontal-def}
  \beta * \alpha = (\beta * G) \bullet (H * \alpha),\\
  \beta * \alpha = (K * \alpha) \bullet (\beta * F).
\end{flalign}

\end{document}
