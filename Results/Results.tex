% !TeX root = Results.tex
\documentclass[../Dissertation.tex]{subfiles}

\begin{document}

\section{Contribution}
Example use cases will be given to illustrate the practical contribution of the developed application, beyond the underlying theory provided in Section \ref{sec:towardsatool}. Petri nets presented in this section were created using the LaTeX exported by the application.

\subsection{Dinaturals in the wild}
Perhaps the most apparent use case for the developed application, is computing and presenting the dinaturality condition for a user provided type. Recall that dinaturality conditions correspond to free theorems. Accordingly, a Petri net generated from a type can also be read as the free theorem of that type. 
\par
A collection of ubiquitous dinatural transformations, found within the application, will be illustrated. Furthermore, the corresponding free theorems will be provided. Images of each Petri net, being created within the application, are given in Appendix \ref{app:wilddinaturals}.

Observe the type of the \lstinline{filter} function
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
filter :: (a -> Bool) -> [a] -> [a].
\end{lstlisting}
\end{tabular}
\end{center}
An equivalent representation, within the application, is given by
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(a -> Bool) => List a -> List a,
\end{lstlisting}
\end{tabular}
\end{center}
with the default naturality type
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(0 -> 0) => 0 -> 0.
\end{lstlisting}
\end{tabular}
\end{center}
Providing this as input, in conjunction with the type variable \lstinline{a}, and exporting the result to LaTeX, yields
\begin{center}
  \begin{tikzcd}
    & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} &  \\
    & {\tikz[baseline=(char.base)]{\node[shape=rectangle,draw,minimum size=12pt,inner sep=0pt,fill=gray] (char) {};}} \arrow[u] \arrow[rd] &  \\
    {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {$f$};}} \arrow[ru] &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {};}}
    \end{tikzcd}.
\end{center}
\noindent
Given a predicate \lstinline{p : b -> Bool}, and a function \lstinline{f : a -> b}, this corresponds to the free theorem
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
filter p . map f = map f . filter (p . f).
\end{lstlisting}
\end{tabular}
\end{center}
\par
Observe the type of the \lstinline{foldr} function
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
foldr :: (a -> b -> b) -> b -> [a] -> b.
\end{lstlisting}
\end{tabular}
\end{center}
An equivalent representation, within the application, is given by
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(a -> b -> b) => b -> List a -> b,
\end{lstlisting}
\end{tabular}
\end{center}
with the default naturality type
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(0 -> 0 -> 0) => 0 -> 0 -> 0.
\end{lstlisting}
\end{tabular}
\end{center}
Providing this as input, in conjunction with the type variable \lstinline{b}, and exporting the result to LaTeX, yields
\begin{center}
  \begin{tikzcd}
    {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {$f$};}} \arrow[ld] \\
      & {\tikz[baseline=(char.base)]{\node[shape=rectangle,draw,minimum size=12pt,inner sep=0pt,fill=gray] (char) {};}} \arrow[lu] \arrow[rd] &  \\
    {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {$f$};}} \arrow[ru] &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {};}}
    \end{tikzcd}.
\end{center}
\noindent
Given an accumulator \lstinline{u : a -> c -> b}, and a function \lstinline{f : b -> c}, this corresponds to the free theorem
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[basicstyle=\ttfamily,style=haskellStyle]
foldr (\x -> f . u x) . f = 
\y -> f . foldr (\x -> u x . f) y.
\end{lstlisting}
\end{tabular}
\end{center}
Observe the type of the \lstinline{span} function
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
span :: (a -> Bool) -> [a] -> ([a], [a])
\end{lstlisting}
\end{tabular}
\end{center}
An equivalent representation, within the application, is given by
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(a -> Bool) => List a -> Pair (List a) (List a),
\end{lstlisting}
\end{tabular}
\end{center}
with the default naturality type
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(0 -> 0) => 0 -> (0) (0).
\end{lstlisting}
\end{tabular}
\end{center}
Providing this as input, in conjunction with the type variable \lstinline{a}, and exporting the result to LaTeX, yields
\begin{center}
  \begin{tikzcd}
    & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} &  \\
    & {\tikz[baseline=(char.base)]{\node[shape=rectangle,draw,minimum size=12pt,inner sep=0pt,fill=gray] (char) {};}} \arrow[u] \arrow[d] \arrow[rd] &  \\
    {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {$f$};}} \arrow[ru] & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {};}} & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {};}}
    \end{tikzcd}.
\end{center}
\noindent
Given a predicate \lstinline{p : b -> Bool}, and a function \lstinline{f : a -> b}, this corresponds to the free theorem
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
span p . map f = 
bimap (map f) (map f) . span (p . f).
\end{lstlisting}
\end{tabular}
\end{center}
Observe the type of the \lstinline{groupBy} function
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
groupBy :: (a -> a -> Bool) -> [a] -> [[a]].
\end{lstlisting}
\end{tabular}
\end{center}
An equivalent representation, within the application, is given by
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(a -> a -> Bool) => List a -> List (List a),
\end{lstlisting}
\end{tabular}
\end{center}
with the default naturality type
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(0 -> 0 -> 0) => 0 -> 0.
\end{lstlisting}
\end{tabular}
\end{center}
\noindent
Providing this as input, in conjunction with the type variable \lstinline{a}, and exporting the result to LaTeX, yields
\begin{center}
  \begin{tikzcd}
    {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} \\
      & {\tikz[baseline=(char.base)]{\node[shape=rectangle,draw,minimum size=12pt,inner sep=0pt,fill=gray] (char) {};}} \arrow[lu] \arrow[ru] \arrow[rd] &  \\
    {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {$f$};}} \arrow[ru] &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {};}}
    \end{tikzcd}
\end{center}
\noindent
Given a relation \lstinline{r :: b -> b -> Bool} and a function \lstinline{f :: a -> b}, this corresponds to the free theorem
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[basicstyle=\ttfamily,style=haskellStyle]
groupBy r . map f =
(map . map) f . groupBy (\x y -> r (f x) (f y)).
\end{lstlisting}
\end{tabular}
\end{center}
\noindent
Observe the type of the \lstinline{insertBy} function
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
\end{lstlisting}
\end{tabular}
\end{center}
An equivalent representation, within the application, is given by
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(a -> a -> Ordering) => a -> List a -> List a,
\end{lstlisting}
\end{tabular}
\end{center}
with the default naturality type
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(0 -> 0 -> 0) => 0 -> 0 -> 0.
\end{lstlisting}
\end{tabular}
\end{center}
Providing this as input, in conjunction with the type variable \lstinline{a}, and exporting the result to LaTeX, yields
\begin{center}
  \begin{tikzcd}[column sep=tiny]
    & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} &  \\
    &  & {\tikz[baseline=(char.base)]{\node[shape=rectangle,draw,minimum size=12pt,inner sep=0pt,fill=gray] (char) {};}} \arrow[lu] \arrow[ru] \arrow[rrd] &  &  \\
    {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {$f$};}} \arrow[rru] &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {$f$};}} \arrow[u] &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {};}}
    \end{tikzcd}
\end{center}
\noindent
Given an ordering \lstinline{o : b -> b -> Ordering}, and a function \lstinline{f : a -> b}, this corresponds to the free theorem
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(. map f) . insertBy o . f =
map f . insertBy ((. f) . o . f).
\end{lstlisting}
\end{tabular}
\end{center}
Observe the type of the \lstinline{dicata} function
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,style=haskellStyle]
dicata :: (Base a (b, a) -> b) -> (Base a (b, a) -> a) -> a -> b.
\end{lstlisting}
\end{tabular}
\end{center}
An equivalent representation, within the application, is given by
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,style=haskellStyle]
(Base a (Pair b a) -> b) => (Base a (Pair b a) -> a) -> a -> b,
\end{lstlisting}
\end{tabular}
\end{center}
with the default naturality type
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(0 (0 0) -> 0) => (0 (0 0) -> 0) -> 0 -> 0.
\end{lstlisting}
\end{tabular}
\end{center}
Providing this as input, in conjunction with the type variable \lstinline{a}, and exporting the result to LaTeX, yields
\begin{center}
  \begin{tikzcd}[column sep=tiny]
    &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} &  &  \\
    &  &  & {\tikz[baseline=(char.base)]{\node[shape=rectangle,draw,minimum size=12pt,inner sep=0pt,fill=gray] (char) {};}} \arrow[lu] \arrow[ru] \arrow[llld] \arrow[ld] &  &  &  \\
    {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {};}} &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {};}} &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {$f$};}} \arrow[lu] &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {$f$};}} \arrow[lllu]
    \end{tikzcd}.
\end{center}
Observe the type of the \lstinline{prepro} function
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,style=haskellStyle]
prepro :: (Base a a -> Base a a) -> (Base b a -> a) -> b -> a.
\end{lstlisting}
\end{tabular}
\end{center}
An equivalent representation, within the application, is given by
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,style=haskellStyle]
(Base a a -> Base a a) => (Base b a -> a) -> b -> a,
\end{lstlisting}
\end{tabular}
\end{center}
with the default naturality type
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(0 0 -> 0 0) => (0 0 -> 0) -> 0 -> 0.
\end{lstlisting}
\end{tabular}
\end{center}
Providing this as input, in conjunction with the type variable \lstinline{a}, and exporting the result to LaTeX, yields
\begin{center}
  \begin{tikzcd}[column sep=tiny]
  {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {$f$};}} \arrow[ld] &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {$f$};}} \arrow[llld] \\
    &  &  & {\tikz[baseline=(char.base)]{\node[shape=rectangle,draw,minimum size=12pt,inner sep=0pt,fill=gray] (char) {};}} \arrow[lllu] \arrow[lu] \arrow[lld] \arrow[rrd] &  &  &  \\
    & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {};}} &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {$f$};}} \arrow[u] &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {};}} & 
  \end{tikzcd}.
\end{center}

\subsection{Currying and Naturality}

\begin{center}
  \begin{tikzcd}
    {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} &  & {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=white] (char) {$f$};}} \arrow[ld] \\
      & {\tikz[baseline=(char.base)]{\node[shape=rectangle,draw,minimum size=10pt,inner sep=0pt,fill=black] (char) {};}} \arrow[lu] & 
    \end{tikzcd}
\end{center}

\begin{center}
  \begin{tikzcd}
    {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {};}} \\
    {\tikz[baseline=(char.base)]{\node[shape=rectangle,draw,minimum size=12pt,inner sep=0pt,fill=black] (char) {};}} \arrow[u] \\
    {\tikz[baseline=(char.base)]{\node[shape=circle,draw,minimum size=20pt,inner sep=0pt,fill=lightgray] (char) {$f$};}} \arrow[u]
    \end{tikzcd}
\end{center}


\end{document}